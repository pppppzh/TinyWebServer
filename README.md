# TinyWebServer

## 1.buffer类
由于使用非阻塞I/O模型，所以需要实现应用层buffer。即在应用程序发送数据时，并不需要关注生产的数据如何发送（一次性或分成多次发送），只需要调用send()函数，将数据交给buffer，等待socket变为可写时buffer将存储的数据进行发送。同理，在应用程序接受数据时，由于TCP协议是无边界的字节流协议，极大可能会出现数据流不完整情况，所以收到的数据要放到buffer中，等接受消息完整后，再通知应用程序进行读取。

buffer类的设计参考了muduo网络库，内部使用vector\<char>进行数据存储。为了防止迭代器失效的问题，buffer类中使用了两个int类型的成员变量作为index，即readIndex、writeIndex。两个index将vector分成三份：prependable、readable、writable。当向buffer写入数据，writeIndex向后移动；当从buffer取出数据，readIndex向后移动。经过多次读写后，readIndex可能移动到较后的位置，留下了较大的prependable空间，此时如果写入的数据大小大于writable空间并且小于writable+prependable的大小，buffer不会重新分配内存，而是把已有的数据移动到prependable。

在buffer::ReadFd()函数中，在栈上申请了一个stackbuff，利用readv()读取数据，将数据读入到buffer和stackbuf中。当读入的数据不多时，全部读入buffer中；如果长度超过buffer大小，就会读到stackbuff中。减少了系统调用的同时，降低了系统内存占用。


## 2.日志系统
由于日志记录数据涉及到文件I/O操作，当日志数据较大时，同步模式可能会阻塞程序的处理流程，导致并发性较低。所以需要使用异步模式的日志，将需要记录的日志数据先存入阻塞队列中，由其他线程从阻塞队列中取出内容，写入日志。blockqueue类使用deque实现，类内的成员函数实现参照了生产者消费者模型，通过搭配锁和条件变量保证了线程安全。

log类的设计模式为单例模式，保证只有一个log类的实例，并提供Instance()函数作为全局访问点。

## 3.线程池与连接池
线程池主要解决了两个问题：1.提高资源利用率，通过预先创建一组线程并对其进行复用，减少了线程频繁创建和销毁所造成的时间和资源损耗。2.提高线程可管理性，通过线程池对线程进行统一分配调控。可以管理线程并发数量，从而降低线程之间的竞争，增加性能。

连接池用于解决在高并发情况下，频繁向数据库申请、释放资源带来性能损耗的问题。为数据库的连接创建一个缓存池，提前放入一定量的连接，当多个任务需要访问数据库时，不需要再去通过TCP连接MySQL server，直接在缓存池中取对应数量的连接即可。用完之后也不需要释放连接，只需要还回缓存即可。

